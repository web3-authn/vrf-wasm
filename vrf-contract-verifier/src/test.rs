//! Cross-verification tests between vrf-wasm (proof generation) and vrf-contract-verifier (proof verification)
//!
//! These tests ensure that VRF proofs generated by the main vrf-wasm library can be
//! verified by the vrf-contract-verifier library

#[cfg(test)]
mod tests {
    use crate::verifiers;
    use crate::types::VerificationError;

    // Import the main vrf-wasm library for proof generation
    use vrf_wasm::vrf::ecvrf::ECVRFKeyPair;
    use vrf_wasm::vrf::{VRFKeyPair, VRFProof};
    use vrf_wasm::serde_helpers::ToFromByteArray;
    use vrf_wasm::rng;

    #[test]
    fn test_cross_verification_basic() {
        // Generate a VRF keypair using the main vrf-wasm library
        let mut rng_instance = rng::WasmRng;
        let keypair = ECVRFKeyPair::generate(&mut rng_instance);

        // Create test input
        let input = b"test_input_for_vrf";

        // Generate VRF proof using vrf-wasm
        let proof = keypair.prove(input);
        let vrf_output = proof.to_hash();

        // Extract public key bytes
        let pk_bytes = keypair.public_key().to_byte_array();

        // Extract proof components
        let (gamma_bytes, challenge_bytes, scalar_bytes) = proof.to_components();

        // Reconstruct proof bytes in the format expected by vrf-contract-verifier
        // Format: gamma(32) + challenge(16) + scalar(32) = 80 bytes total
        let mut proof_bytes = Vec::with_capacity(80);
        proof_bytes.extend_from_slice(&gamma_bytes);
        proof_bytes.extend_from_slice(&challenge_bytes);
        proof_bytes.extend_from_slice(&scalar_bytes);

        // Verify using vrf-contract-verifier
        let verification_result = verifiers::verify_vrf(
            &proof_bytes,
            &pk_bytes,
            input,
        );

        // Assert verification succeeds
        assert!(verification_result.is_ok(), "VRF proof verification failed: {:?}", verification_result.err());

        // Assert the output matches
        let verified_output = verification_result.unwrap();
        assert_eq!(verified_output, vrf_output, "VRF outputs do not match");
    }

    #[test]
    fn test_cross_verification_multiple_inputs() {
        // Test with multiple different inputs to ensure robustness
        let test_inputs = [
            b"test_input_1".as_slice(),
            b"test_input_2",
            b"different_seed_value",
            b"",  // Empty input
            b"very_long_input_that_exceeds_normal_length_to_test_edge_cases_and_ensure_robustness",
            &[0u8; 32],  // All zeros
            &[255u8; 16], // All ones (shorter)
        ];

        // Generate a single keypair for all tests
        let mut rng_instance = rng::WasmRng;
        let keypair = ECVRFKeyPair::generate(&mut rng_instance);
        let pk_bytes = keypair.public_key().to_byte_array();

        for (i, input) in test_inputs.iter().enumerate() {
            // Generate VRF proof using vrf-wasm
            let proof = keypair.prove(input);
            let vrf_output = proof.to_hash();

            // Extract proof components and reconstruct proof bytes
            let (gamma_bytes, challenge_bytes, scalar_bytes) = proof.to_components();
            let mut proof_bytes = Vec::with_capacity(80);
            proof_bytes.extend_from_slice(&gamma_bytes);
            proof_bytes.extend_from_slice(&challenge_bytes);
            proof_bytes.extend_from_slice(&scalar_bytes);

            // Verify using vrf-contract-verifier
            let verification_result = verifiers::verify_vrf(
                &proof_bytes,
                &pk_bytes,
                input,
            );

            // Assert verification succeeds
            assert!(
                verification_result.is_ok(),
                "VRF proof verification failed for input {}: {:?}",
                i,
                verification_result.err()
            );

            // Assert the output matches
            let verified_output = verification_result.unwrap();
            assert_eq!(
                verified_output, vrf_output,
                "VRF outputs do not match for input {}",
                i
            );
        }
    }

    #[test]
    fn test_cross_verification_different_keypairs() {
        // Test with multiple different keypairs to ensure consistency
        let input = b"consistent_test_input";

        for i in 0..5 {
            // Generate a new keypair for each iteration
            let mut rng_instance = rng::WasmRng;
            let keypair = ECVRFKeyPair::generate(&mut rng_instance);
            let pk_bytes = keypair.public_key().to_byte_array();

            // Generate VRF proof using vrf-wasm
            let proof = keypair.prove(input);
            let vrf_output = proof.to_hash();

            // Extract proof components and reconstruct proof bytes
            let (gamma_bytes, challenge_bytes, scalar_bytes) = proof.to_components();
            let mut proof_bytes = Vec::with_capacity(80);
            proof_bytes.extend_from_slice(&gamma_bytes);
            proof_bytes.extend_from_slice(&challenge_bytes);
            proof_bytes.extend_from_slice(&scalar_bytes);

            // Verify using vrf-contract-verifier
            let verification_result = verifiers::verify_vrf(
                &proof_bytes,
                &pk_bytes,
                input,
            );

            // Assert verification succeeds
            assert!(
                verification_result.is_ok(),
                "VRF proof verification failed for keypair {}: {:?}",
                i,
                verification_result.err()
            );

            // Assert the output matches
            let verified_output = verification_result.unwrap();
            assert_eq!(
                verified_output, vrf_output,
                "VRF outputs do not match for keypair {}",
                i
            );
        }
    }

    #[test]
    fn test_cross_verification_invalid_proof() {
        // Test that invalid proofs are correctly rejected
        let mut rng_instance = rng::WasmRng;
        let keypair = ECVRFKeyPair::generate(&mut rng_instance);
        let pk_bytes = keypair.public_key().to_byte_array();

        let input = b"test_input";

        // Generate a valid proof
        let proof = keypair.prove(input);
        let (gamma_bytes, challenge_bytes, scalar_bytes) = proof.to_components();

        // Test 1: Corrupt the gamma component
        let mut corrupted_proof_bytes = Vec::with_capacity(80);
        let mut corrupted_gamma = gamma_bytes;
        corrupted_gamma[0] ^= 0xFF; // Flip first byte
        corrupted_proof_bytes.extend_from_slice(&corrupted_gamma);
        corrupted_proof_bytes.extend_from_slice(&challenge_bytes);
        corrupted_proof_bytes.extend_from_slice(&scalar_bytes);

        let result = verifiers::verify_vrf(
            &corrupted_proof_bytes,
            &pk_bytes,
            input,
        );
        assert!(result.is_err(), "Corrupted gamma should fail verification");

        // Test 2: Corrupt the challenge component
        let mut corrupted_proof_bytes = Vec::with_capacity(80);
        let mut corrupted_challenge = challenge_bytes;
        corrupted_challenge[0] ^= 0xFF; // Flip first byte
        corrupted_proof_bytes.extend_from_slice(&gamma_bytes);
        corrupted_proof_bytes.extend_from_slice(&corrupted_challenge);
        corrupted_proof_bytes.extend_from_slice(&scalar_bytes);

        let result = verifiers::verify_vrf(
            &corrupted_proof_bytes,
            &pk_bytes,
            input,
        );
        assert!(result.is_err(), "Corrupted challenge should fail verification");

        // Test 3: Corrupt the scalar component
        let mut corrupted_proof_bytes = Vec::with_capacity(80);
        let mut corrupted_scalar = scalar_bytes;
        corrupted_scalar[0] ^= 0xFF; // Flip first byte
        corrupted_proof_bytes.extend_from_slice(&gamma_bytes);
        corrupted_proof_bytes.extend_from_slice(&challenge_bytes);
        corrupted_proof_bytes.extend_from_slice(&corrupted_scalar);

        let result = verifiers::verify_vrf(
            &corrupted_proof_bytes,
            &pk_bytes,
            input,
        );
        assert!(result.is_err(), "Corrupted scalar should fail verification");
    }

    #[test]
    fn test_cross_verification_wrong_public_key() {
        // Test that proofs fail verification with wrong public key
        let mut rng_instance = rng::WasmRng;

        // Generate two different keypairs
        let keypair1 = ECVRFKeyPair::generate(&mut rng_instance);
        let keypair2 = ECVRFKeyPair::generate(&mut rng_instance);

        let input = b"test_input";

        // Generate proof with keypair1
        let proof = keypair1.prove(input);
        let (gamma_bytes, challenge_bytes, scalar_bytes) = proof.to_components();
        let mut proof_bytes = Vec::with_capacity(80);
        proof_bytes.extend_from_slice(&gamma_bytes);
        proof_bytes.extend_from_slice(&challenge_bytes);
        proof_bytes.extend_from_slice(&scalar_bytes);

        // Try to verify with keypair2's public key (should fail)
        let wrong_pk_bytes = keypair2.public_key().to_byte_array();
        let result = verifiers::verify_vrf(
            &proof_bytes,
            &wrong_pk_bytes,
            input,
        );

        assert!(result.is_err(), "Verification with wrong public key should fail");
        assert!(matches!(result.err(), Some(VerificationError::InvalidProof)));
    }

    #[test]
    fn test_cross_verification_wrong_input() {
        // Test that proofs fail verification with wrong input
        let mut rng_instance = rng::WasmRng;
        let keypair = ECVRFKeyPair::generate(&mut rng_instance);
        let pk_bytes = keypair.public_key().to_byte_array();

        let original_input = b"original_input";
        let wrong_input = b"wrong_input";

        // Generate proof with original input
        let proof = keypair.prove(original_input);
        let (gamma_bytes, challenge_bytes, scalar_bytes) = proof.to_components();
        let mut proof_bytes = Vec::with_capacity(80);
        proof_bytes.extend_from_slice(&gamma_bytes);
        proof_bytes.extend_from_slice(&challenge_bytes);
        proof_bytes.extend_from_slice(&scalar_bytes);

        // Try to verify with wrong input (should fail)
        let result = verifiers::verify_vrf(
            &proof_bytes,
            &pk_bytes,
            wrong_input,
        );

        assert!(result.is_err(), "Verification with wrong input should fail");
        assert!(matches!(result.err(), Some(VerificationError::InvalidProof)));
    }

    #[test]
    fn test_cross_verification_fixed_array_api() {
        // Test the fixed-array API as well
        let mut rng_instance = rng::WasmRng;
        let keypair = ECVRFKeyPair::generate(&mut rng_instance);

        let input = b"test_input_for_fixed_api";

        // Generate VRF proof using vrf-wasm
        let proof = keypair.prove(input);
        let vrf_output = proof.to_hash();

        // Extract components and create fixed arrays
        let pk_bytes = keypair.public_key().to_byte_array();
        let (gamma_bytes, challenge_bytes, scalar_bytes) = proof.to_components();

        // Create 80-byte proof array
        let mut proof_array = [0u8; 80];
        proof_array[0..32].copy_from_slice(&gamma_bytes);
        proof_array[32..48].copy_from_slice(&challenge_bytes);
        proof_array[48..80].copy_from_slice(&scalar_bytes);

        // Verify using the fixed-array API
        let verification_result = verifiers::verify_vrf_fixed(
            &proof_array,
            &pk_bytes,
            input,
        );

        // Assert verification succeeds
        assert!(verification_result.is_ok(), "Fixed-array VRF proof verification failed: {:?}", verification_result.err());

        // Assert the output matches
        let verified_output = verification_result.unwrap();
        assert_eq!(verified_output, vrf_output, "Fixed-array VRF outputs do not match");
    }

    #[test]
    fn test_cross_verification_boolean_api() {
        // Test the boolean verification API
        let mut rng_instance = rng::WasmRng;
        let keypair = ECVRFKeyPair::generate(&mut rng_instance);
        let pk_bytes = keypair.public_key().to_byte_array();

        let input = b"test_input_for_boolean_api";

        // Generate VRF proof using vrf-wasm
        let proof = keypair.prove(input);
        let (gamma_bytes, challenge_bytes, scalar_bytes) = proof.to_components();

        // Create proof bytes
        let mut proof_bytes = Vec::with_capacity(80);
        proof_bytes.extend_from_slice(&gamma_bytes);
        proof_bytes.extend_from_slice(&challenge_bytes);
        proof_bytes.extend_from_slice(&scalar_bytes);

        // Test valid proof
        let is_valid = verifiers::verify_vrf_bool(
            proof_bytes.clone(),
            pk_bytes.to_vec(),
            input.to_vec(),
        );
        assert!(is_valid, "Valid proof should return true");

        // Test invalid proof (corrupted)
        let mut invalid_proof = proof_bytes;
        invalid_proof[0] ^= 0xFF; // Corrupt first byte
        let is_valid = verifiers::verify_vrf_bool(
            invalid_proof,
            pk_bytes.to_vec(),
            input.to_vec(),
        );
        assert!(!is_valid, "Invalid proof should return false");
    }

    #[test]
    fn test_proof_component_structure() {
        // Generate a VRF keypair using the main vrf-wasm library
        let mut rng_instance = rng::WasmRng;
        let keypair = ECVRFKeyPair::generate(&mut rng_instance);

        // Create test input
        let input = b"test_input_for_vrf";

        // Generate VRF proof using vrf-wasm
        let proof = keypair.prove(input);
        let vrf_output = proof.to_hash();

        // Extract proof components
        let (gamma_bytes, challenge_bytes, scalar_bytes) = proof.to_components();

        // Verify the component structure matches what vrf-contract-verifier expects
        assert_eq!(gamma_bytes.len(), 32, "Gamma component should be 32 bytes");
        assert_eq!(challenge_bytes.len(), 16, "Challenge component should be 16 bytes");
        assert_eq!(scalar_bytes.len(), 32, "Scalar component should be 32 bytes");

        // Verify we can reconstruct the 80-byte proof format
        let mut proof_bytes = Vec::with_capacity(80);
        proof_bytes.extend_from_slice(&gamma_bytes);
        proof_bytes.extend_from_slice(&challenge_bytes);
        proof_bytes.extend_from_slice(&scalar_bytes);

        assert_eq!(proof_bytes.len(), 80, "Complete proof should be exactly 80 bytes");

        // Verify the VRF output is 64 bytes as expected
        assert_eq!(vrf_output.len(), 64, "VRF output should be 64 bytes");

        println!("✅ Proof structure test passed - suite string compatibility verified");
    }

    #[test]
    fn test_suite_string_constants() {
        // This test verifies that both libraries use the same domain separation approach
        // by checking that the constants match

        // The suite string used in vrf-wasm should be "sui_vrf" (7 bytes)
        // The challenge domain separator should be 0x02
        // The output domain separator should be 0x03

        // We can't directly compare constants across crates, but we can verify
        // that our verification logic expects the same structure

        let test_gamma = [1u8; 32];
        let test_challenge = [2u8; 16];
        let test_scalar = [3u8; 32];

        // Construct a test proof in the expected format
        let mut test_proof_bytes = Vec::with_capacity(80);
        test_proof_bytes.extend_from_slice(&test_gamma);
        test_proof_bytes.extend_from_slice(&test_challenge);
        test_proof_bytes.extend_from_slice(&test_scalar);

        assert_eq!(test_proof_bytes.len(), 80);

        // Test that the verifier correctly parses the proof structure
        let test_pk = [4u8; 32];
        let test_input = b"test";

        // This should fail verification (invalid proof), but should parse correctly
        let result = verifiers::verify_vrf(
            &test_proof_bytes,
            &test_pk,
            test_input,
        );

        // We expect this to fail, but not due to parsing errors
        assert!(result.is_err(), "Invalid test proof should fail verification");

        println!("✅ Suite string structure test passed");
    }
}
